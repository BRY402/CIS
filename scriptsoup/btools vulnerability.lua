warn([[Loaded btools vulnerability script
Made by BRY402 (BRY402#8989)]])
local owner = game:GetService("Players").LocalPlayer
local tools = owner.Backpack:FindFirstChild("Building Tools") or owner.Character:FindFirstChild("Building Tools") or owner.Backpack:WaitForChild("Building Tools")
local event = _G.ServerEvent or tools:WaitForChild("SyncAPI"):WaitForChild("ServerEndpoint")
_G.ServerEvent = event
local function invoke(t)
event:InvokeServer(unpack(t))
end
local function addcontentstotable(t,t2)
coroutine.resume(coroutine.create(function()
for i,v in ipairs(t2) do
t[i] = v
end
end))
end
local function multisync(data,taskdata,al,typ)
local multidata = {}
if not typ then
for i,v in pairs(data) do
local ndfmd = {Part = v}
addcontentstotable(ndfmd,taskdata)
table.insert(multidata,ndfmd)
if al then
task.wait()
end
end
else
if typ == "Resize" then
for i,v in pairs(data) do
local ndfmd = {Part = v}
taskdata.CFrame = taskdata.CFrame or v.CFrame
addcontentstotable(ndfmd,taskdata)
table.insert(multidata,ndfmd)
if al then
task.wait()
end
end
elseif typ == "Rotate" then
for i,v in pairs(data) do
local ndfmd = {Part = v}
taskdata.CFrame = v.CFrame * taskdata.Ori
taskdata.Ori = nil
addcontentstotable(ndfmd,taskdata)
table.insert(multidata,ndfmd)
if al then
task.wait()
end
end
end
end
return multidata
end
local Classes = {Block = "Normal",
Truss = "Truss",
Wedge = "Wedge",
Corner = "Corner",
Cylinder = "Cylinder",
Ball = "Ball",
Seat = "Seat",
VehicleSeat = "Vehicle Seat",
SpotLight = "SpotLight",
PointLight = "PointLight",
SurfaceLight = "SurfaceLight",
Fire = "Fire",
Sparkles = "Sparkles",
Smoke = "Smoke"}
local btools = {}
function btools.BtColor(...)
local bta = {
    "RecolorHandle",
    BrickColor.new(...)}
invoke(bta)
end
function btools.new(typ,parent,cf)
local toc = string.lower(typeof(cf))
if toc == "vector3" then
cf = CFrame.new(cf)
end
assert(typeof(cf) == "CFrame","btools.new error: CFrame or Vector3 expected, got "..typeof(cf))
local typ = tostring(typ)
assert(typeof(parent) == "Instance","btools.new error: Invalid parent type")
local bta = {"CreatePart",
typ,
cf,
parent}
return invoke(bta)
end
function btools.destroy(...)
local data = {...}
local bta = {"Remove",
data}
invoke(bta)
return data
end
function btools.undestroy(...)
local data = ...
if typeof(data) == "table" then
else
data = {...}
end
local bta = {"UndoRemove",
data}
invoke(bta)
end
function btools.Color(data,color,al)
local multidata = multisync(data,{Color = color,
UnionColoring = true},al)
local bta = {"SyncColor",
multidata}
invoke(bta)
end
function btools.Move(data,cf,al)
local multidata = multisync(data,{CFrame = cf},al)
local bta = {"SyncMove",
multidata}
invoke(bta)
end
function btools.Resize(data,size,cf,al)
local multidata = multisync(data,{CFrame = cf,
Size = size},al,"Resize")
local bta = {"SyncResize",
multidata}
invoke(bta)
end
function btools.Rotate(data,size,ori,al)
local multidata = multisync(data,{Ori = ori,
Size = size},al,"Rotate")
local bta = {"SyncRotate",
multidata}
invoke(bta)
end
function btools.SetPartProperty(data,properties,al)
warn("SetPartProperties is very limited and can only do 3 actions:\nTransparency\nReflection\nMaterial")
local pr = {}
addcontentstotable(properties,pr)
local multidata = multisync(data,pr,al)
local bta = {"SyncMaterial",
multidata}
invoke(bta)
end
function btools.newmesh(data,al)
local multidata = {}
for i,v in ipairs(data) do
table.insert(multidata,{Part = v})
if al then
task.wait()
end
end
local bta = {"CreateMeshes",
multidata}
return invoke(bta)
end
function btools.newtexture(data,typ,properties,al)
local pr = {TextureType = typ}
addcontentstotable(pr,properties)
pr.Face = pr.Face or "Front"
local multidata = multisync(data,pr,al)
local bta = {"CreateTextures",
multidata}
return invoke(bta)
end
function btools.Weld(data,main)
local bta = {"CreateWelds",
data,
main}
return invoke(bta)
end
function btools.Unweld(welds)
local bta = {"RemoveWelds",
welds}
invoke(bta)
end
function btools.newlight(data,typ,al)
local multidata = {}
for i,v in ipairs(data) do
table.insert(multidata,{Part = v,LightType = typ})
if al then
task.wait()
end
end
local bta = {"CreateLights",
multidata}
return invoke(bta)
end
function btools.neweffect(data,typ,al)
local multidata = {}
for i,v in ipairs(data) do
table.insert(multidata,{Part = v,DecorationType = typ})
if al then
task.wait()
end
end
local bta = {"CreateDecorations",
multidata}
return invoke(bta)
end
function btools.SetAnchored(data,anchor)
local multidata = multisync(data,{Anchored = anchor},al)
local bta = {"SyncAnchor",
multidata}
invoke(bta)
end
function btools.SetCanCollide(data,cc)
local multidata = multisync(data,{CanCollide = cc},al)
local bta = {"SyncCollision",
multidata}
invoke(bta)
end
function btools.SetEffectProperties(data,typ,properties,al)
local pr = {DecorationType = typ}
addcontentstotable(pr,properties)
local multidata = multisync(data,pr,al)
local bta = {"SyncDecorate",
multidata}
invoke(bta)
end
function btools.SetLightingProperties(data,typ,properties,al)
local pr = {LightType = typ}
addcontentstotable(pr,properties)
local multidata = multisync(data,pr,al)
local bta = {"SyncDecorate",
multidata}
invoke(bta)
end
function btools.SetTextureProperties(data,typ,properties,al)
local pr = {TextureType = typ}
addcontentstotable(pr,properties)
local multidata = multisync(data,pr,al)
local bta = {"SyncTexture",
multidata}
invoke(bta)
end
function btools.SetMeshProperties(data,properties,al)
local multidata = multisync(data,properties,al)
local bta = {"SyncMesh",
multidata}
invoke(bta)
end
function btools.SetName(data,name)
local bta = {"SetName",
data,
name}
invoke(bta)
end
function btools.Clone(data,parent)
local bta = {"Clone",
data,
parent}
end
function btools.Export(data)
local bta = {"Export",
data}
return invoke(bta)
end
function btools.SetSurface(data,surfaces,al)
local multidata = multisync(data,{Surfaces = surfaces},al)
local bta = {"SyncSurface",
multidata}
invoke(bta)
end
return btools
